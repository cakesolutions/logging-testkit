// Copyright 2018 Cake Solutions Limited
// Copyright 2016-2017 Carl Pulley

package net.cakesolutions.testkit

import scala.concurrent.duration._

import com.typesafe.scalalogging.Logger
import monix.reactive.Observable
import monix.reactive.Notification.{OnComplete, OnError, OnNext}

import net.cakesolutions.testkit.config.Configuration

package object monitor {

  import Configuration._
  import Interactions._

  private val logger = Logger(Logging.name)

  /**
    * Type for describing IOAutomata state machines using partial functions.
    *
    * @tparam IOState IOAutomata state type
    * @tparam Event event type
    */
  type Behaviour[IOState, Event] =
    PartialFunction[IOState, PartialFunction[EventIn[Event], Action[IOState]]]

  /**
    * Implicit for adding `monitor` methods to observables.
    *
    * @param upstream upstream observable that will emit events
    * @tparam IOState IOAutomata state type
    * @tparam Event event type
    */
  implicit class ObservableMonitor[IOState, Event](upstream: Observable[Event]) {

    private val clock: Observable[EventInternal[Event]] =
      Observable.timerRepeated(Timeout.delay, Timeout.period, Tick)

    /**
      * Using an IOAutomata, monitor the upstream observable and emit notification actions downstream.
      *
      * @param initialState state that monitoring IOAutomata will start in
      * @param initialTimeout (optional) timeout for how long we may linger in the starting state
      * @param overallTimeout (optional) timeout for how long this IOAutomata will monitor
      * @param transition partial function describing the monitoring behaviour as an IOAutomata
      * @return observable of notification actions generated by monitoring the upstream event observable
      */
    def monitor(
      initialState: IOState,
      initialTimeout: Option[FiniteDuration] = None,
      overallTimeout: Option[FiniteDuration] = None
    )(
      transition: Behaviour[IOState, Event]
    ): Observable[ActionOut[Notify]] = {
      Observable.merge[EventInternal[Event]](upstream.asEventInternal, clock)
        .debugLog("IN")
        .materialize
        .scan[MonitorState[IOState]](RunningState(initialState).timeout(initialTimeout).overall(overallTimeout)) {
          case (current: RunningState[IOState], obs@OnNext(event: Observe[Event]))
            if transition.isDefinedAt(current.state) &&
              transition(current.state).isDefinedAt(event) =>
            val result = next(transition)(current, event)
            logger.trace(s"monitor: $obs transitions from $current to $result")
            result
          case (current: RunningState[IOState], obs@OnNext(Tick))
            if current.stateTimeout.exists(_.isOverdue()) &&
              transition.isDefinedAt(current.state) &&
              transition(current.state).isDefinedAt(StateTimeout) =>
            val result = next(transition)(current, StateTimeout)
            logger.trace(s"monitor: $obs transitions from $current to $result")
            result
          case (current: RunningState[IOState], obs@OnNext(Tick))
            if current.overallTimeout.exists(_.isOverdue()) &&
              transition.isDefinedAt(current.state) &&
              transition(current.state).isDefinedAt(MonitorTimeout) =>
            val result = next(transition)(current, MonitorTimeout)
            logger.trace(s"monitor: $obs transitions from $current to $result")
            result
          case (current: RunningState[IOState], obs@OnComplete) =>
            logger.trace(s"monitor: $obs transitions from $current to COMPLETE")
            complete(current.state)
          case (current: RunningState[IOState], obs@OnNext(event: Observe[Event])) =>
            logger.trace(s"monitor: $obs transitions from $current to ERROR")
            error(current.state, TransitionFailure(event))
          case (current: RunningState[IOState], obs@OnError(exn)) =>
            logger.trace(s"monitor: $obs transitions from $current to ERROR")
            error(current.state, exn)
          case (current: RunningState[IOState], obs@OnNext(Tick))
            if current.stateTimeout.exists(_.isOverdue()) =>
            logger.trace(s"deadline: $obs transitions from $current to ERROR")
            error(current.state, StateTimeout)
          case (current: RunningState[IOState], obs@OnNext(Tick))
            if current.overallTimeout.exists(_.isOverdue()) =>
            logger.trace(s"deadline: $obs transitions from $current to ERROR")
            error(current.state, MonitorTimeout)
          case (current: RunningState[IOState], obs@OnNext(Tick)) =>
            logger.trace(s"deadline: $obs transitions from $current to ERROR")
            current
          case (current: ShutdownState[IOState], obs) =>
            logger.trace(s"monitor: $obs transitions from $current to SHUTDOWN")
            ShutdownState(current.state)
        }
        .flatMap {
          case state: RunningState[IOState] =>
            state.actions
          case state: ShutdownState[IOState] =>
            state.actions
        }
        .dematerialize
        .debugLog("OUT")
    }

    /**
      * @see net.cakesolutions.testkit.monitor.ObservableMonitor#monitor
      */
    def monitor(automata: IOAutomata[IOState, Event]): Observable[ActionOut[Notify]] = {
      monitor(automata.initialState, automata.initialTimeout, automata.overallTimeout)(automata.transition)
    }

    private def next(transition: Behaviour[IOState, Event])(state: RunningState[IOState], event: EventIn[Event]): MonitorState[IOState] = {
      transition(state.state)(event) match {
        case Goto(nextState, duration, action) =>
          state.copy(state = nextState).output(action).timeout(duration)
        case Stay(action) =>
          state.output(action)
        case Stop(action) =>
          ShutdownState(state.state, actions = Observable(OnNext(Observe(action)), OnComplete))
      }
    }

    private def error(state: IOState, exn: Throwable): ShutdownState[IOState] = {
      ShutdownState(state, actions = Observable(OnError(exn)))
    }

    private def complete(state: IOState): ShutdownState[IOState] = {
      ShutdownState(state, actions = Observable(OnComplete))
    }
  }

  private implicit class EventInMap[Event](upstream: Observable[Event]) {
    def debugLog(tag: String): Observable[Event] = {
      upstream
        .materialize
        .zipWithIndex
        .map {
          case (event, index) =>
            logger.debug(s"$tag-$index: $event")
            event
        }
        .dematerialize
    }

    def asEventInternal: Observable[EventInternal[Event]] = {
      upstream.map { event: Event =>
          Observe(event)
      }
    }
  }

  private implicit class TimeoutBehaviour[IOState](state: RunningState[IOState]) {
    def output(emit: Option[Notify]): RunningState[IOState] = emit match {
      case Some(action) =>
        RunningState(state.state, overallTimeout = state.overallTimeout, actions = Observable(OnNext(Observe[Notify](action))))
      case None =>
        RunningState(state.state, overallTimeout = state.overallTimeout)
    }

    def timeout(timeout: Option[FiniteDuration]): RunningState[IOState] = {
      state.copy(stateTimeout = timeout.map(_.fromNow))
    }

    def overall(timeout: Option[FiniteDuration]): RunningState[IOState] = {
      state.copy(overallTimeout = timeout.map(_.fromNow))
    }
  }
}
